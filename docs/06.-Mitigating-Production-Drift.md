Production Drift is very similar to Hot Fix deployment, but unlike Hot Fix where production changes are well known, The drift includes procedures outlined to identify the changes.

- [1. Create  Drift Branch](#1-create--drift-branch)
- [2. Refresh Drift Branch](#2-refresh-drift-branch)
- [3. Delete All](#3-delete-all)
- [4. Export](#4-export)
- [5. Revert Noise](#5-revert-noise)
  - [5.1. ORDS, USERS, and APEX SQL Files](#51-ords-users-and-apex-sql-files)
  - [5.2. Whitespace](#52-whitespace)
  - [5.3. Whitespace and Empty Lines](#53-whitespace-and-empty-lines)
  - [5.4. Snapshots](#54-snapshots)
  - [5.5. Columns Order](#55-columns-order)
  - [5.6. 5.5 APEX Yaml](#56-55-apex-yaml)
- [6. Review Real Drift](#6-review-real-drift)
  - [6.1. Create a Hotfix](#61-create-a-hotfix)
  - [6.2. Update Main](#62-update-main)
  - [6.3. When Main is AHead of Production](#63-when-main-is-ahead-of-production)
- [7. Revert all chnages and leave the branch](#7-revert-all-chnages-and-leave-the-branch)


> In a losely controlled environments, drift may be recommended before any push to production 

# 1. Create  Drift Branch

- If this is a first drift, start with creating a drift branch. This will be a long-living branch that would be never merged into main.
- If this is not your first drift for this repo, go to section 2. 

```bash
git checkout main 
git pull
git checkout -b drift
```

- Next, configure filters the way that support drift detection. The filters should exclude all objects drift  you don't expect to ( for example ORDS schemas, user definitions, system priveleges and etc.)

For example, filters in `.dbtools/filters/project.filters` may look like the following:

```sql
export_type not in ('USER','USER_SYS_PRIVS','USER_ROLE_PRIVS' ),
export_type not in ('ORDS_SCHEMA'),
APEX_APPLICATIONS.application_group ='Prod',
```

Skip the next section and go to section 3

# 2. Refresh Drift Branch

If you already had a drift switch into the drift branch and rebase it from main

```bash
git checkout main 
git pull
git checkout drift
git merge main
```

> If  you have merge conflicts while merging main into drift, you will see the following output:

```
$ git merge main
Auto-merging .dbtools/filters/project.filters
Auto-merging src/database/cla_apex/apex_apps/f104/f104.sql
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f104/f104.sql
Auto-merging src/database/cla_apex/apex_apps/f110/f110.sql
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f110/f110.sql
Auto-merging src/database/cla_apex/apex_apps/f110/readable/application/f110.yaml
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f110/readable/application/f110.yaml
Auto-merging src/database/cla_apex/apex_apps/f110/readable/workspace/app_groups.yaml
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f110/readable/workspace/app_groups.yaml
Auto-merging src/database/cla_apex/apex_apps/f116/f116.sql
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f116/f116.sql
Auto-merging src/database/cla_apex/apex_apps/f116/readable/application/f116.yaml
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f116/readable/application/f116.yaml
Auto-merging src/database/cla_apex/apex_apps/f202/f202.sql
CONFLICT (content): Merge conflict in src/database/cla_apex/apex_apps/f202/f202.sql
``` 

- In this case you need to accept all changes from main for src and keep drift filter 

```bash
git checkout --theirs -- src/
git checkout --ours -- .dbtools/filters/project.filters
git add .
git commit -m 'ready for drift detection Nov 27, 2025'
```

# 3. Delete All
- Now delete all files under src/ in the working tree that you expect to be regenerated by export:

```bash
rm -fR src/database/cla_apex src/database/cla_public/ src/database/cla_utilities/
```

# 4. Export

- Connect to prod in SQLcl and export everything according to the filters:
( Use 10 threads)
```sql
conn -name proj_prod
proj export -t 10 -v
```

- To avoid any issues due to EOL-conversion stage the chnages

```bash
git add .
```


# 5. Revert Noise 

Revert changes that you cannot analyse , for example apex apps sql files or changes you expect to have for techncial reasons

## 5.1. ORDS, USERS, and APEX SQL Files

```bash
git restore --staged --worktree -- src/database/*/ords/ords.sql
git restore --staged --worktree -- src/database/*/users/*.sql"
git restore --staged --worktree -- src/database/*/apex_apps/f*/f*.sql
git restore  .
```

## 5.2. Whitespace 

Revert white-space-only changes

```bash
for f in $(git diff --cached --name-only); do
  if ! git diff --cached -w -- "$f" | grep -q '^diff'; then
    echo "Restoring $f"
    git restore --staged --worktree -- "$f"
  fi
done

```

## 5.3. Whitespace and Empty Lines

Revert whitespace changes that include empty lines

```bash
for f in $(git diff --cached --name-only); do
  # --cached  = compare index vs HEAD
  # -w        = ignore all whitespace in line comparison
  # -I'^[[:space:]]*$' = ignore hunks where all changed lines are whitespace-only (incl. empty)
  # --quiet   = no output, just exit code (0 = no non-whitespace diff)
  if git diff --cached -w -I'^[[:space:]]*$' --quiet -- "$f"; then
    echo "Restoring $f"
    git restore --staged --worktree -- "$f"
  fi
done
```

## 5.4. Snapshots

- Revert files  only differernt in snapshot 

```bash
for f in $(git diff --cached --name-only); do
  # Ignore hunks where ALL changed lines match ^-- sqlcl_snapshot
  if git diff --cached -I'^-- sqlcl_snapshot' --quiet -- "$f"; then
    echo "Restoring $f"
    git restore --staged --worktree -- "$f"
  fi
done
```

## 5.5. Columns Order 

- Revert files that only different in snapshot, empty lines, and order of columns 

```bash
normalize() {   sed '/^-- sqlcl_snapshot/d' "$1" |        # remove snapshot line
  sed 's/[[:space:]]\+$//g'         |        # strip trailing whitespace
  sed '/^$/d'                        |        # drop empty lines
  sed 's/\([^,]\)$/\1,\n/'            |        # add comma if missing
  #tr -d '[:space:]'                 |        # remove remaining spaces/tabs
  sort                              |        # canonicalize order
  uniq                               # dedupe if SQLcl duplicated entries
}

for f in $(git diff --cached --name-only); do
  # write staged version to temp
  git show :$f > /tmp/staged.txt 2>/dev/null || continue
  # write HEAD version to temp
  git show HEAD:$f > /tmp/head.txt 2>/dev/null || continue

  if diff -q <(normalize /tmp/head.txt) <(normalize /tmp/staged.txt) >/dev/null; then
    echo "RESTORE (only ordering/snapshot changed): $f"
    git restore --staged --worktree -- "$f"
  fi
done

```

## 5.6. 5.5 APEX Yaml

- Version-Number 
```bash
for f in $(git diff --cached --name-only -- 'src/database/*/apex_apps/*/readable/*'); do
  if git diff --cached -I'version-number:\s*[0-9]+' --quiet -- "$f"; then
    echo "Restoring version-number-only change: $f"
    git restore --staged --worktree -- "$f"
  fi
done
```

- And id

```bash
for f in $(git diff --cached --name-only -- 'src/database/*/apex_apps/*/readable/*'); do
  if git diff --cached -I'id:\s*[0-9]+' --quiet -- "$f"; then
    echo "Restoring version-number-only change: $f"
    git restore --staged --worktree -- "$f"
  fi
done
```


# 6. Review Real Drift 

Go over remaining  diffs in VS code ; identify and address real differences.
Document required changes. There can be these outcomes:

## 6.1. Create a Hotfix

Legitimate production changes that have never been reported should be identified, organized in a hotfix and dealt with as described  in [5. Hotfix](5.-Hot-Fix-Deployment.md)

## 6.2. Update Main 

If changes correspond to changes in production database that are already done, but not require hotfix, for example, delete old or temporary objects from main, create a branch , make these chanages and request merging into main.

## 6.3. When Main is AHead of Production

Ignore changes resulting from features merged into main after testing and before deployment to prod. Presense of these chnages indicates what would be changed by the next deployment.



# 7. Revert all chnages and leave the branch 

At the end of drift detection always revert all changes in drift branch done by the latest `project export`

```bash
git restore --staged --worktree -- .
```